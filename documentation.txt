Udemy Next JS Course - Stephen Grider


Section 01 - Get Started Here !

01. How to Learn NextjJS Quickly

02. Project Overview
-u terminalu instaliramo NextJS aplikaciju sa komandom npx create-next-app@latest 
-udemo u folder sa komandom cd corp
-u terminal ukucamo komandu npm run dev da pokrenemo Next JS aplikaciju

03. File-Based Routing
-u page.tsx fajlu izbrisemo sadrzaj u jsx-u i ostavimo samo jedan div element

04. Adding Additional Routes
-kreiramo foldere performance, reliability i scale
-u svakom kreiranom folderu kreiramo page.tsx fajl
-u svakom page.tsx fajlu kreiramo i eksportujemo funkciju

05. Linking Between Pages
-u app/page.txs fajl importujemo komponentu Link iz pakete next/link
-u jsx-u kreiramo div element za komponente Link
-kreiramo tri komponente Link sa prop href

06. Common UI in Next JS with Layouts
-u globals.css fajlu izbrisemo CSS stil 
-iz app/page.tsx fajla premjestamo div element sa komponetama Link u layout.tsx fajl
-u layout.txs fajlu kreiramo jos jednu komponentu Link koja ce nas navigirati na home page

07. Project Structure Strategy
-u folderu src kreiramo folder components
-u folderu components kreiramo header.tsx komponentu
-u layout.tsx fajl importujemo komponentu header.tsx

08. Absolute Path Import Shortcut
-u layout.tsx fajl dodajemo @ kod importa komponente header.tsx

09. Image Files + Import Update
-preuzmemo folder sa slikama koje su potrebne za projekt

10. Adding Images in Next JS
-kreiramo folder public i koji dodajemo prethodno preuzete slike
-u app/page.tsx fajl importujemo komponentu Image iz next/image paketa
-importujemo sliku homeImg 

11. More on the Image Component
-u app/page.tsx fajlu komponenti Image dodajemo prop width i height

12. Adding a Reusable Presentation Component
-u folderu components kreiramo komponentu hero.tsx
-div element sa slikom iz app/page.tsx fajla premjestamo u komponentu hero.tsx 
-u komponentu hero.tsx importujemo tip StaticImageData iz paketa next/image
-importujemo komponentu Image iz paketa next/image
-kreiramo interfejs interface HeroProps
-u interfejs HeroProps dodajemo opcije imgData, imgAlt i title
-kreiramo div element koji ce da sluzi gradient 
-funkciji Hero() dodajemo parametar props: HeroProps
-u jsx-u komponenti Image, dodajemo u src i alt vrijednosti imgData i imgAlt 
-kreiramo div element i unutar njega h1 element
-u h1 element dodajemo naslov props.title
-u app/page.tsx fajl importujemo komponentu hero.tsx
-u jsx-u kreiramo komponentu Hero
-komponenti Hero dodajemo prop imgData, imgAlt i title

13. Adding Some Styling
-u folderima performance, reliability i scale, u page.tsx fajlove dodajemo slike i komponentu Hero
-u komponentu header.tsx dodajemo Tailwind CSS stil 

14. Production Deployment with Vercel
-u terminalu navigiramo u folder cd corp i ukucamo komandu npx vercel
-pratimo uputstva iz videa
-u .gitignore fajlu dodana opcija .vercel
-otvorimo web stranicu https://vercel.com/ da vidimo nas projekt
-otvorimo link: https://udemy-nextjs-course-sg-01-section-corp.vercel.app/

15. Join Our Community!
-link za pristup Diskord serveru

16. Course Diagrams
-preuzet folder sa dijagramima 
-kreiran folder 00-diagrams sa pdf fajlovima


Section 02: Changing Data with Mutations

17. App Overview
-kreiramo Next.js projekt sa imenom snippets

18. Project Setup
-u terminalu navigiramo u projekt snippets u ukucamo komandu npm i prisma
-u terminalu ukucamo komandu npx prisma init --datasource-provider sqlite
-u schema.prisma fajlu kreiramo model Snippet
-u terminal ukucamo komandu npx prisma migrate dev

19. Adding a Create Page
-u globals.css fajlu izbrisemo css stil
-u app/page.tsx fajlu ostavimo samo div element
-u folderu app kreiramo folder snippets
-u folderu snippets kreiramo folder new
-u folderu new kreiramo page.tsx fajl

20. Creating a Prisma Client within Next.js
-u src folderu kreiramo folder db i index.ts fajl
-i index.ts fajl importujemo funkciju PrismaClient iz Prisma paketa
-dodajemo metodu new PrismaClient()
-vrijednost metode new PrismaClient() pohranjujemo u varijablu const db
-eksportujemo varijablu const db

21. Adding a Creation Form
-u layout.tsx fajlu kreiramo div element sa Tailwind CSS klasama u koji dodajemo prop children
-u page.tsx fajlu kreiramo HTML elemente sa Tailwind CSS klasama za formu


Section 03: Streaming Content with React Server Components

22. Introduction Server Actions in Next.js
-u snippets/new page.tsx fajlu kreiramo asinhronu funkciju createSnippet()
-u funkciju createSnippet() dodajemo direktivu 'use server'
-funkciji createSnippet() dodajemo parametar formData
-parametru formData dodajemo tip FormData
-kreiramo varijable const title i const code
-importujemo instancu db
-dodajemo metodu await db.snippet.create()
-vrijednost metode await db.snippet.create() pohranjujemo u varijablu const snippet
-importujemo funkciju redirect iz paketa next/navigation
-u funkciju createSnippet() dodajemo funkciju redirect('/')
-u jsx-u form elementu dodajemo prop action
-u prop action proslijedujemo funkciju createSnippet

23. A Deeper Dive into Server Actions

24. Server Components vs Client Components

25. Fetching Data with Server Components
-u app/page.tsx fajl importujemo instancu db
-funkciji Home() dodajemo async
-u funkciju Home() dodajemo metodu await db.snippet.findMany()
-vrijednost metode await db.snippet.findMany() pohranjujemo varijablu const snippets
-dodajemo metodu snippets.map()
-vrijednost metode snippets.map() pohranjujemo u varijablu const renderedSnippets
-u jsx-u prikazujemo varijablu renderedSnippets

26. Adding Dynamic Paths
-u folderu snippets kreiramo folder [id] i page.tsx fajl
-u [id]/page.tsx fajlu, funkciji SnippetShowPage() dodajemo parametar props i tip any

27. Fetching Particular Records
-u [id]/page.tsx fajlu funkciji SnippetShowPage() dodajemo async
-importujemo instancu db
-kreiramo interface SnippetShowPageProps
-u funkciji SnippetShowPage() parametru props dodajemo tip SnippetShowPageProps
-dodajemo metodu await db.snippet.findFirst()
-vrijednost metode await db.snippet.findFirst() pohranjujemo u varijablu const snippet
-dodajemo uslov if (!snippet)
-importujemo funkciju notFound iz paketa next/navigation
-u uslov if (!snippet) dodajemo funkciju notFound()

28. Custom Not Found Pages
-u folderu [id] kreiramo not-found.tsx fajl
-u not-found.tsx fajlu kreiramo funkciju SnippetNotFound()

29. Automatic Loading Spinners
-u folderu [id] kreiramo loading.tsx fajl
-u loading.tsx fajlu kreiramo funkciju SnippetLoadingPage()
-otvorimo rutu http://localhost:3000/snippets/1 da vidimo poruku kako se ocitavaju podaci

30. A Few Quick Tasks
-u app/page.tsx fajl importujemo komponentu Link iz paketa next/link
-u metodi map() kreiramo komponentu Link
-komponenti Link dodajemo prop href, key i className
-u jsx-u kreiramo HTML elemente sa Tailwind CSS klasama

31. Styling the Show Page
-u snippets/[id]/page.tsx fajlu kreiramo HTML elemente i dodajemo im Tailwind CSS klase 

32. Linking to the Edit Page
-u folderu [id] kreiramo folder edit i page.tsx fajl
-u edit/page.tsx fajlu kreiramo funkciju SnippetEditPage()
-kreiramo interface SnippetEditPageProps
-funkciji SnippetEditPage() dodajemo parameter props
-parametru props dodajemo tip SnippetEditPageProps
-kreiramo varijablu const id
-u snippets/[id]/page.tsx fajl importujemo i kreiramo komponentu Link
-ujsx-u komponenti Link dodajemo prop href i dinamicku rutu po id-u biljeske

33. Showing a Client Component in a Server Component
-u [edit]/page.tsx fajl importujemo funkciju notFound i instancu db
-kreiramo varijable const id i const snippet
-dodajemo uslov if (!snippet)
-u uslov if (!snippet) dodajemo funkciju notFound()
-u folderu src kreiramo folder components
-u folderu components kreiramo komponentu SnippetEditForm.jsx
-funkciji SnippetEditForm() dodajemo parametar destruktuirani prop snippet
-kreiramo interface SnippetEditFormProps
-dodajemo direktivu 'use client'
-importujemo tip Snippet iz paketa prisma/client
-parametru snippet dodajemo tip SnippetEditFormProps
-u edit/page.jsx fajl importujemo komponentu SnippetEditForm.jsx
-funkciji SnippetEditPage() dodajemo async
-u jsx-u kreiramo komponentu SnippetEditForm
-komponenti SnippetEditForm dodajemo prop snippet
-u prop snippet proslijedujemo vrijednost varijable snippet

34. Adding the Monaco Editor
-otvorimo link https://www.npmjs.com/package/@monaco-editor/react
-u terminalu instaliramo paket Monaco Editor sa komandom npm i @monaco-editor/react
-u komponentu SnippetEditForm.tsx importujemo komponentu Editor iz paketa monaco-editor/react
-u jsx-u kreiramo komponentu Editor
-komponenti Editor dodajemo prop height, theme, language, defaultValue i options

35. Handling Editor Changes
-u komponenti SnippetEditForm.tsx kreiramo funkciju handleEditorChange()
-funkciji handleEditorChange() dodajemo parametar value
-parametru value dodajemo tip string = ''
-komponenti Editor dodajemo prop onChange
-u prop onChange proslijedujemo funkciju handleEditorChange
-importujemo funkciju React Hook useState
-kreiramo state varijablu const code i set funkciju setCode
-u funkciju handleEditorChange() dodajemo funkciju setCode(value)


Section 04: Server Actions in Greate Detail

36. Server Actions in Nextjs Client Components

37. Server Actions in a Separate File
-u folderu src kreiramo folder actions
-u folderu actions kreiramo index.ts fajl
-u index.ts fajl dodajemo direktivu 'use server'
-importujemo instancu db
-kreiramo i eksportujemo asinhronu funkciju editSnippet()
-u komponentu SnippetEditForm.tsx importujemo funkciju editSnippet

38. Options for Calling Server Actions from Client Components

39. Calling a Server Action from a Client Component
-u actions/index.ts fajlu funkciji editSnippet() dodajemo parametre id i code
-parametrima id i code dodajemo tip number i string
-u komponenti SnippetEditForm.tsx dodajemo metodu editSnippet.bind()
-vrijednost metode editSnippet.bind() pohranjujemo u varijablu const editSnippetAction 
-u jsx-u kreiramo form element
-form elementu dodajemo prop action
-u prop action proslijedujemo funkciju editSnippetAction
-u form elementu kreiramo button element
-button elementu dodajemo prop type i className
-u actions/index.ts fajlu, u funkciju editSnippet() dodajemo metodu await db.snippet.update()
-importujemo i kreiramo funkciju redirect()

40. Deleting a Record with a Server Action
-u actions/index.ts fajlu kreiramo i eksportujemo asinhronu funkciju deleteSnippet()
-u funkciju deleteSnippet() dodajemo metodu await db.snippet.delete()
-u snippets/[id]/page.tsx fajl importujemo funkciju deleteSnippet
-dodajemo metodu deleteSnippet.bind()
-vrijednost metode deleteSnippet.bind() pohranjujemo u varijablu const deleteSnippetAction
-u jsx-u kreiramo form element
-form elementu dodajemo prop action
-u prop action proslijedujemo vrijednost funkcije deleteSnippetAction


Section 05: Server Forms with the UseFormState Hook

41. Understanding the UseFormState Hook

42. UseFormState State in Action
-funkciju createSnippet() premjestamo iz new/page.tsx fajla u actions/index.ts fajl
-u index.ts fajlu funkciji createSnippet() dodajemo parametar formState
-u new/page.tsx fajl importujemo i kreiramo funkciju useFormState iz paketa react-dom
-importujemo funkciju createSnippet
-funkciji useFormState() dodajemo argumente funkciju createSnippet i objekt sa porukom
-dodajemo direktivu 'use client'
-vrijednost funkcije useFormState() pohranjujemo u varijable const [formState, action]
-u prop action proslijedujemo funkciju action
-u jsx-u kreiramo div element u koji dodajemo varijablu formState.message

43. Adding the Form Validation
-u actions/index.ts fajlu dodajemo uslov if u kojem provjerama da li je varijabla title string i da li sadrzi manje od 3 slova
-dodajemo uslov if za varijablu code
-u if uslove dodajemo return i objekt message
-kreiramo novu zabiljesku 

44. Gotchas Around Error Handling in Nextjs
-u folderu new kreiramo error.tsx fajl
-u error.tsx fajl dodajemo direktivu 'use client'
-kreiramo funkciju ErrorPage()
-kreiramo interface ErrorPageProps
-funkciji ErrorPage() dodajemo parametar destruktuirani prop error
-parametru error dodajemo tip ErrorPageProps
-u jsx-u kreiramo div element u koji dodajemo error poruku
-u actions/index.ts fajl, u funkciju createSnippet() dodajemo blokove koda try - catch
-u blok koda catch dodajemo uslove if (err instanceof Error) - else


Section 06: Understanding Next's Caching System

45. Super Unexpected Behaviour
-u terminalu ukucamo komandu npm run build
-u terminalu ukucamo komandu npm run start

46. The Full Route Cache System

47. What Makes a Static or Dynamic Route in Next.js
-u app/page.tsx fajlu kreiramo i eksportujemo varijablu const dynamic

48. When to Use Each Cache Control

49. Help, My Page is Showing Old Data!
-u actions/index.ts fajl importujemo funkciju revalidatePath iz paketa next/cache
-u funkcije deleteSnippet() i createSnippet() dodajemo funkciju revalidatePath()
-u terminalu ukucamo komandu npm run build
-u terminalu ukucamo komandu npm run start

50. Enabling Caching with GenerateStaticParams

51. Caching Dynamic Routes
-u snippets/[id]/page.tsx fajlu kreiramo i eksportujemo funkciju generateStaticParams()
-u funkciju generateStaticParams() dodajemo metodu await db.snippet.findMany()
-vrijednost metode await db.snippet.findMany() pohranjujemo u varijablu const snippets
-dodajemo metodu snippets.map()
-u terminalu ukucamo komandu npm run build
-u actions/index.ts fajlu, u funkciju editSnippet() dodajemo funkciju revalidatePath() za id
-u funkciju deleteSnippet() dodajemo jos jednu funkciju revalidatePath() za id
-u terminalu ukucamo komande npm run build i npm run start


Section 07: Authentication with Next-Auth

52. Next 14.2 Issues and Required Version

53. Project Overview
-u terminalu ukucamo komandu npx create-next-app

54. Critical Libraries in Our Project

55. NextUI Installation and Setup
-u terminalu ukucamo komandu npm i --save-exact @nextui-org/react@2.2.9 framer-motion
-u tailwind.config.js fajl importujemo funkciju nextui iz paketa nextui-org/react
-dodajemo opciju darkMode
-u opciju za plugins dodajemo funkciju nextui()
-u folderu app kreiramo providers.tsx fajl
-u providers.tsx fajl dodajemo direktivu 'use client'
-importujemo funkciju NextUIProvider iz paketa nextui-org/react
-kreiramo interface ProvidersProps
-kreiramo i eksportujemo funkciju Providers()
-funkciji Providers() dodajemo parametar destruktuirani prop children
-parametru children dodajemo tip ProvidersProps
-u jsx-u kreiramo komponentu NextUIProvider sa otvorenim i zatvorenim tagom
-u komponentu NextUIProvider dodajemo prop children
-u layout.tsx fajl importujemo komponentu Providers
-u jsx-u kreiramo komponentu Providers sa otvorenim i zatvorenim tagom
-u komponentu Providers dodajemo prop children
-u app/page.tsx fajl importujemo komponentu Button iz paketa nextui-org/react
-u jsx-u izbrisemo postojece HTML elemente i kreiramo novi div element
-u div elementu kreiramo komponentu Button
-u globals.css fajlu izbrisemo postojeci CSS stil
-u terminalu pokrenemo projekt sa komandom npm run dev

56. Prisma Schema File
-preuzet schema.prisma fajl

57. Database Setup
-u terminalu instaliramo paket prisma sa komandom npm i prisma
-u terminalu ukucamo komandu npx prisma init --datasource-provider sqlite
-u schema.prisma fajl kreiramo potrebne modele za projekt
-u terminalu ukucamo komandu npx prisma migrate dev
-kreiramo folder db i index.ts fajl
-u index.ts fajl importujemo funkciju PrismaClient iz paketa prisma/client
-dodajemo metodu new PrismaClient()
-vrijednost metode new PrismaClient() pohranjujemo u varijablu const db
-eksportujemo varijablu const db

58. OAuth Setup
-otvorimo link https://github.com/settings/applications/new da kreiramo novi OAuth Aplikaciju
-u Homepage URL stavimo link http://localhost:3000
-u Application Description dodamo opis aplikacije
-u Authorization callback URL stavimo link http://localhost:3000/api/auth/callback/github
-kad unesemo potrebne podatke kliknemo dugme za Registraciju aplikacije
-kreiramo fajlove .env.local i .env.local.example
-u .env.local fajlu kreiramo tri varijable GITHUB_CLINT_ID, GITHUB_CLIENT_SECRET i AUTH_SECRET
-otvorimo link https://auth-secret-gen.vercel.app/ da generisemo kod za AUTH_SECRET
-u terminalu instaliramo Auth pakete
-u terminalu ukucamo komandu npm i --save-exact @auth/core@0.18.1 @auth/prisma-adapter@1.0.6 next-auth@5.0.0-beta.3

59. Next-Auth Setup
-u folderu src kreiramo auth.ts fajl
-u auth.ts fajl importujemo instance NextAuth i Github
-importujemo funkciju PrismaAdapter
-importujemo instancu db
-kreiramo varijable cosnt GITHUB_CLIENT_ID i const GITHUB_CLIENT_SECRET
-dodajemo uslov if (!GITHUB_CLIENT_ID || GITHUB_CLIENT_SECRET)
-kreiramo funkciju NextAuth()
-u funkciji NextAuth() kreiramo konfiguracioni objekt
-u konfiguracioni objekt dodajemo opcije adapter, providers i callbacks
-vrijednost funkcije NextAuth() pohranjujemo u destruktuirane varijable const { handlers, auth, signOut, signIn }
-iz varijable handlers destruktuiramo metode GET i POST

60. The Theory Behind OAuth
-u folderu app kreiramo foldere api, auth, [...nextauth] i route.ts fajl
-u route.ts fajlu eksportujemo funkcije GET i POST
-u .eslintrc.json fajl dodajemo objekt rules

61. Wrapping Auth in Server Actions
-u folderu src kreiramo folder actions i index.ts fajl
-u index.ts fajl dodajemo direktivu 'use server'
-dodajemo import * as auth from '@/auth'
-kreiramo i eksportujemo asinhrone funkcije signIn() i signOut()

62. Sign In, Sign Out and Checking Auth Status
-u app/page.tsx fajl dodajemo import * as actions from '@/actions'
-u jsx-u, u div elementu kreiramo form element
-form elementu dodajemo prop action
-u prop action dodajemo action.signIn
-Button komponenti dodajemo prop type
-kliknemo Sign in dugme da se prijavi pomocu Github-a
-kreiramo jos jednu form element za komponentu Button Sign Out
-u app/page.tsx fajl importujemo i kreiramo funkciju auth()
-funkciji Home() dodajemo async
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-u jsx-u dodajemo ternarni uslov session?.user 
-u providers.tsx fajl importujemo komponentu SessionProvider iz paketa next-auth/react
-u jsx-u kreiramo komponentu SessionProvider sa otvorenim i zatvorenim tagom
-u src folderu kreiramo folder components
-u folderu components kreiramo komponentu Profile.tsx
-u komponentu Profile.tsx dodajemo direktivu 'use client'
-importujemo i kreiramo funkciju useSession() iz paketa next-auth/react
-vrijednost funkcije useSession() pohranjujemo u varijablu const session
-dodajemo uslov if (session.data?.user)
-u jsx-u kreiramo div element
-u app/page.tsx fajl importujemo komponentu Profile.tsx

63. Upfront Design Process
-otvorimo web stranicu https://miro.com/
-planiranje projekta

64. Why Path Helpers ?

65. Path Helper Implementation
-u folderu src kreiramo paths.ts fajl
-u paths.ts fajlu kreiramo objekt varijablu const paths
-u objektu kreiramo funkcije home(), topicShow(), postCreate() i postShow()
-funkcijama topicShow(), postCreate() i postShow() dodajemo parametar topicSlug: string
-funkciji postShow() dodajemo jos i parametar postId: string
-u return izjave dodajemo putanju ruta

66. Creating the Routing 
-u folderu src kreiramo foldere topics, [slug] i posts jedan unutar drugog
-u folderu [slug] kreiramo page.tsx fajl
-u folderu posts kreiramo foldere [postId] i new
-u folderima [postId] i new kreiramo page.tsx fajlove

67. Stubbing Out Server Actions
-u folderu actions kreiramo fajlove create-comment.ts, create-post.ts i create-topic.ts
-u createTopic.ts fajlu kreiramo i eksportujemo asinhronu funkciju createTopic()
-u createPost.ts fajlu kreiramo i eksportujemo asinhronu funkciju createPost()
-u createComment.ts fajlu kreiramo i eksportujemo asinhronu funkciju createComment()
-kreiramo fajlove sign-in.ts i sign-out.ts
-u sign-in.ts fajl premjestamo funkciju signIn iz index.ts fajla
-u sign-out.ts fajl premjestamo funkciju signOut iz index.ts fajla
-u index.ts fajlu eksportujemo sve funkcije iz foldera actions

68. Planning Revalidating Strategies
-u folderu actions, u ts fajlove dodajemo komentar sta se treba uraditi

69. Building the Header
-u folderu components kreiramo komponentu Header.tsx
-importujemo komponentu Link za paketa next/link
-importujemo komponente iz paketa nextui-org/react
-importujemo i kreiramo funkciju auth iz auth.ts fajla
-funkciji Header() dodajemo async
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-u jsx-u kreiramo komponentu Navbar sa otvorenim i zatvorenim tagom
-u komponenti Navbar kreiramo komponentu NavbarBrand sa otvorenim i zatvorenim tagom
-u komande NavbarBrand kreiramo komponentu Link
-komponenti Link dodajemo prop href i className
-kreiramo dvije komponente NavbarContent
-u komponenti NavbarContent kreiramo komponentu NavbarItem sa otvorenim i zatvorenim tagom
-komponenti NavbarContent dodajemo prop justify
-u komponenti NavbarItem kreiramo komponentu Input
-drugoj komponenti NavbarContent dodajemo prop justify
-u komponenti NavbarContent kreiramo komponentu NavbarItem
-u komponentu NavbarItem dodajemo ternarni uslov za varijablu session?.user 
-u layout.tsx fajl importujemo komponentu Header.jsx
-u jsx-u kreiramo div element sa Tailwind CSS klasama
-u div element dodajemo komponentu Providers
-u komponentu Providers dodajemo komponentu Header

70. Displaying the Sign In and Sign Out Buttons
-u komponenti Header.jsx kreiramo varijablu let authContent
-varijabli authContent dodajemo tip React.ReactNode
-dodajemo uslov if (session?.user) else
-u uslov if (session?.user) dodajemo vrijednost komponente Avatar varijabli authContent
-u uslov else dodajemo dvije komponente NavbarItem
-u komponentama NavbarItem kreiramo komponente Button sa prop type, color i variant
-u jsx dodajemo varijablu authContent

71. Enabling Sign Out
-u komponentu Header.tsx dodajemo import * as actions
-u komponentama NavbarItem kreiramo form elemente
-form elementima dodajemo prop action
-u form elementima za komponente Sign In i Sign Out dodajemo actions.signIn
-u komponentu Header.tsx importujemo komponente Popover, PopoverTrigger, PopoverContent
-u uslovu if, u varijabli authContent kreiramo komponente Popover sa otvorenim i zatvorenim tagom
-komponenti Popover dodajemo prop placement
-u komponenti Popover kreiramo komponente PopoverTrigger i PopoverContent sa otvorenim i zatvorenim tagom
-u komponentu PopoverTrigger dodajemo komponentu Avatar
-u komponenti PopoverContent kreiramo div element 
-u div elementu kreiramo form element
-form elementu dodajemo prop action
-u prop action proslijedujemo vrijednost actions.signOut
-u form elementu kreiramo komponentu Button Sign Out
-komponenti Button dodajemo prop type

72. More Caching Issues
-u app/page.tsx fajlu izbrisemo kod u jsx-u

73. Signout Issues with Next 14.2

74. Static Caching While Using Auth
-u folderu components kreiramo komponentu HeaderAuth.tsx
-u komponentu HeaderAuth.tsx dodajemo direktivu 'use client'
-importujemo komponente iz paketa nextui-org/react
-importujemo i kreiramo funkciju useSession iz paketa next-auth/react
-importujemo sve funkcije kao actions iz fajla actions
-vrijednost funkcije useSession() pohranjujemo u varijablu const session
-iz komponente Header.tsx premjestamo dio koda u komponentu HeaderAuth.tsx
-u komponenti HeaderAuth.tsx u return izjavu dodajemo varijablu authContent
-u komponentu Header.tsx importujemo komponentu HeaderAuth.tsx
-u jsx-u, u komponentu NavbarContent dodajemo komponentu HeaderAuth
-u komponentu HeaderAuth.tsx dodajemo uslov if (session.status === 'loading')
-dodajemo uslov else if (session.data?.user)
-u terminalu ukucamo komandu npm run build

75. Creating Topics
-u folderu components kreiramo folder topics
-u folderu topics kreiramo komponentu TopicCreateForm.tsx 
-u app/page.tsx fajl importujemo komponentu TopicCreateForm.tsx
-u app/page.tsx fajl importujemo komponentu TopicCreateForm.tsx
-u jsx-u kreiramo div i h1 elemente
-u div element dodajemo komponentu TopicCreateForm
-div elementima dodajemo Tailwind CSS grid klase

76. Creating a Popover Form
-u komponentu TopicCreateForm.tsx importujemo komponente iz paketa nextui-org/react
-u jsx-u kreiramo roditelj element Popover sa otvorenim i zatvorenim tagom
-u komponenti Popover kreiramo komponente PopoverTrigger i PopoverContent sa otvorenim i zatvorenim tagom
-u komponenti PopoverTrigger kreiramo komponentu Button
-u komponenti PopoverContent kreiramo form, div i h3 elemente
-div elementu dodajemo Tailwind CSS flex klase
-u div elementu kreiramo komponente Input, Textarea i Button
-komponentama Input i Textarea dodajemo prop label, labelPlacement i placeholder
-importujemo sve funkcije kao actions iz actions.ts fajla
-form elementu dodajemo prop action
-u prop action proslijedujemo vrijednost actions.createTopic

77. Receiving Form Data
-u komponenti TopicCreateForm.tsx komponentama Input i Textarea dodajemo prop name
-u create-topic.ts fajlu, funkciji createTopic() dodajemo parametar formData i tip FormData
-kreiramo varijabla const name i const description

78. Adding Form Validation with Zod
-otvorimo link https://www.npmjs.com/package/zod
-u terminalu instaliramo paket Zod sa komandom npm install zod
-u create-topic.ts fajl importujemo varijablu z iz paketa zod
-kreiramo metodu z.object()
-u funkciju object() dodajemo konfiguracioni objekt
-vrijednost metode z.object() pohranjujemo u varijablu const createTopicSchema
-u konfiguracioni objekt dodajemo validaciju za varijablu name
-dodajemo validaciju za varijablu description
-u funkciji createTopic() dodajemo metodu createTopicSchema.safeParse()
-u funkciju safeParse() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo key - value par za varijable name i description
-vrijednost ove metode pohranjujemo u varijablu const result
-dodajemo uslov if (!result.success)
-u uslovu if dodajemo console.error()
-u console.error() dodajemo metode flatten() i fieldErrors

79. Reminder on the UseFormState Hook

80. Fixing UseFormState Type Errors
-u komponentu TopicCreateForm.tsx importujemo i kreiramo funkciju useFormState iz paketa react-dom
-dodajemo direktivu 'use client'
-vrijednost funkcije useFormState() pohranjujemo u varijable cosnt [formState, action]
-u funkciju useFormState() dodajemo argumente actions.createTopic i 5
-u form elementu, u prop action proslijedujemo funkciju action
-u create-topic.ts fajlu funkciji createTopic() dodajemo parametar formState i tip number
-nakon uslova if dodajemo return i broj

81. Here's Our FormState Type
-u createTopic.ts fajlu kreiramo interface CreateTopicFormState
-u interfejsu CreateTopicFormState kreiramo objekt error
-u funkciji createTopic() parametru formState dodajemo tip CreateTopicFormState
-funkciji createTopic() dodajemo tip Promise<CreateTopicFormState>
-u return izjavi dodajemo objekt errors
-u uslov if dodajemo return izjavu objekt errors
-u komponenti TopicCreateForm.tsx, kao drugi argument funkcije useFormState() dodajemo objekt erros

82. Displaying Validation Errors
-u komponenti TopicCreateForm.tsx, komponentama Input i Textarea dodajemo prop isInvalid i errorMessage

83. Handling General Form Errors
-u create-topic.ts fajl importujemo i kreiramo funkciju auth
-u interface CreateTopicFormState dodajemo opciju _form?: string[]
-vrijednost metode await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (!session || !session.user)
-u uslov if dodajemo objekt errors
-u objekt errors dodajemo varijablu _form
-u komponenti TopicCreateForm.tsx, u jsx-u dodajemo ternarni uslov za varijablu formState.errors._form

84. Handling Database Errors in Forms
-u create-topic.ts fajl importujemo funkciju redirect, tip Topic, instancu db i instancu paths
-u funkciji createTopic() kreiramo blokove koda try - catch
-kreiramo varijablu let topic: Topic
-u blok koda try dodajemo metodu await db.topic.create()
-vrijednost metode await db.topic.create() pohranjujemo u varijablu topic
-u blok koda catch dodajemo (err: unknown)
-nakon bloka koda try - catch dodajemo funkciju redirect()
-u funkciju redirect dodajemo argument paths.topicShow()
-u blok koda catch dodajemo uslov if (err instanceof Error) i else
-u uslov if i else dodajemo objekt errors
-importujemo funkciju revalidatePath iz paketa next/cache
-u funkciju createTopic() dodajemo funkciju revalidatePath('/')


Section 08: Using Data - Database Queries

85. Showing Loading Spinners with UseFormStatus
-u create-topic.ts fajlu, u funkciju createTopic() dodajemo await new Promise() koji ce da traje jednu sekundu
-u folderu components kreiramo folder common
-u folderu common kreiramo komponentu FormButton.tsx
-u komponenti FormButton.tsx, funkciji FormButton() dodajemo destruktuirani prop children
-kreiramo interface FormButtonProps
-importujemo i kreiramo funkciju useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-importujemo komponentu Button iz paketa nextui-org/react
-u jsx-u kreiramo komponentu Button sa otvorenim i zatvorenim tagom
-komponenti Button dodajemo prop type i isLoading
-u prop isLoading proslijedujemo vrijednost varijable pending
-u komponentu TopicCreateForm.tsx importujemo komponentu FormButton.tsx

86. Fetching and Listing Content from Prisma
-u folderu topics kreiramo komponentu TopicList.tsx
-u komponentu TopicList.tsx importujemo komponentu Link, komponentu Chip iz paketa nextui-org/react i instancu db
-kreiramo i eksportujemo asinhronu funkciju TopicList()
-u funkciju TopicList() dodajemo metodu await db.topic.findMany()
-vrijednost metode await db.topic.findMany() pohranjujemo u varijablu const topics
-dodajemo metodu topics.map()
-vrijednost metode topics.map() pohranjujemo u varijablu const renderedTopics
-u funkciju map() dodajemo return izjavu i kreiramo div element
-u div elementu kreiramo komponente Link i Chip
-u jsx-u kreiramo div element sa Tailwind CSS flex klasama
-u div element dodajemo varijablu renderedTopics
-u app/page.tsx fajl importujemo komponentu TopicList.tsx
-u div elemnt gdje se nalazi komponenta TopicCreateForm dodajemo komponentu TopicList
-importujemo komponentu Divider iz paketa nextui-org/react
-u jsx-u kreiramo komponentu Divider

87. Scaffolding the Topic Show Page
-u [slug]/page.tsx fajlu, kreiramo interface TopicShowPageProps
-u interface TopicShowPageProps dodajemo objekt params
-funkciji TopicShowPage() dodajemo parametar destruktuirani prop params
-parametru params dodajemo tip TopicShowPageProps
-destruktuiramo varijablu const { slug } iz varijable params
-u jsx-u kreiramo div i h2 elemente sa Tailwind CSS klasama
-u h2 element dodajemo varijablu slug

88. Displaying a Creation Form
-u folderu comment kreiramo folder posts i komponentu PostCreateForm.tsx
-u [slug]/page.tsx fajl importujemo komponentu PostCreateForm.tsx
-u jsx-u kreiramo div element u koji dodajemo komponentu PostCreateForm
-u komponentu PostCreateForm.tsx dodajemo direktivu 'use client'
-importujemo komponente iz paketa nextui-org/react
-importujemo komponentu FormButton.tsx
-u jsx-u kreiramo komponentu Popover sa otvorenim i zatvorenim tagom kao roditelj element za ostale komponente
-u komponenti Popover kreiramo komponente PopoverTrigger i PopoverContent sa otvorenim i zatvorenim tagom
-u komponenti PopoverTrigger kreiramo komponentu Button
-u komponenti PopoverContent kreiramo elemente form, div, h3 i dvije komponente Input
-komponentama Input dodajemo prop name, label, labelPlacement i placeholder
-dodajemo komponentu FormButton

89. Applying Validation to Post Creation
-u create-post.ts importujemo potrebne funkcije i instance
-dodajemo metodu z.object()
-vrijednost metode z.object() pohranjujemo u varijablu const createPostSchema
-u funkciju z.object() dodajemo konfiguracioni objekt
-kreiramo interface CreatePostFormState i unutar njega objekt errors
-u objektu errors varijablama title, content i _form dodajemo tipove string[]
-funkciji createPost() dodajemo parametre formState i formData
-parametru formState dodajemo tip CreatePostFormState
-parametru formData dodajemo tip FormData
-funkciji createPost dodajemo tip Promise<CreatePostFormState>
-u funkciji createPost() dodajemo metodu createPostSchema.safeParse()
-u funkciju safeParse() dodajemo konfiguracioni objekt i key - value vrijednosti za varijable title i content
-dodajemo uslov if (!result.success)
-u uslov if dodajemo return izjavu i objekt errors
-nakon uslova if dodajemo jos jednu return izjavu i prazan objekt errors
-u komponentu PostCreateForm.tsx dodajemo import * as actions 
-importujemo i kreiramo funkciju useFormState()
-vrijednost funkcije useFormState() pohranjujemo u varijable const [formState, action]
-komponentama Input dodajemo prop isInvalid i errorMessage
-form elementu dodajemo prop action
-u prop action proslijedujemo funkciju action

90. Checking Authentication Status
-u create-post.ts fajlu dodajemo metodu await auth()
-vrijednost metode await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (!session || !session.user)
-u uslov if dodajemo return izjavu i objekt errors
-u komponentu PostCreateForm.tsx, u jsx-u dodajemo ternarni uslov za varijablu formState.errors._form

91. Passing Additional Args to a Server Action
-u [slug]/page.tsx fajlu, komponenti PostCreateForm dodajemo prop slug
-u prop slug proslijedujemo varijablu slug
-u komponenti PostCreateForm.tsx kreiramo interface PostCreateFormProps
-funkciji PostCreateForm() dodajemo parametar destruktuirani prop slug
-parametru slug dodajemo tip PostCreateFormProps
-argumentu actions.createPost dodajemo metodu .bind()
-u create-post.ts fajlu funkciji createPost() dodajemo parametar slug i tip string
-dodajemo metodu await db.topic.findFirst()
-vrijednost metode await db.topic.findFirst() pohranjujemo u varijablu const topic
-dodajemo uslov if (!topic)
-u uslov if (!topic) dodajemo return izjavu i objekt errors

92. Creating the Record
-u create-post.ts fajlu kreiramo varijablu let post: Post
-kreiramo blokove koda try - catch
-u blok koda try dodajemo metodu await db.post.create()
-vrijednost metode await db.post.create() pohranjujemo u varijablu post
-u funkciju create() dodajemo objekt data koji sadrzi varijable title, content, userId i topicId
-u blok koda catch dodajemo uslov if (err instanceof Error) i else
-u uslov if dodajemo return izjavu i objekt errors
-u uslov else dodajemo return izjavu i objekt errors
-nakon blokova koda try - catch dodajemo funkciju revalidatePath()
-dodajemo funkciju redirect()
-u pretrazivacu u jednoj od tema kreiramo objavu

93. A Few Project Files
-preuzmemo folder files

94. Merging a Few Files
-u next.config.js fajlu kreiramo objekt images
-u folderu components kreiramo folder comments 
-u folderu comments kreiramo komponente CommentCreateForm.tsx, CommentList.tsx i CommentShow.tsx
-u folderu posts kreiramo komponente PostList.tsx i PostShow.tsx

95. Considerations Around Where to Fetch Data

96. Data Fetching in Child Components

97. Recommended Data Fetching

98. Define in Parent, Fetch in Child
-u folderu db kreiramo folder queries
-u folderu queries kreiramo posts.ts fajl
-u posts.ts fajl importujemo tip Post i instancu db
-kreiramo i eksportujemo tip type PostWithData
-kreiramo i eksportujemo funkciju fetchPostsByTopicSlug()
-funkciji fetchPostsByTopicSlug() dodajemo parametar slug i tip string
-u funkciju fetchPostsByTopicSlug() dodajemo metodu db.post.findMany()
-funkciji fetchPostsByTopicSlug() dodajemo tip Promise<PostWithData[]>
-u komponentu PostList.tsx importujemo tip PostWithData
-kreiramo interface PostListProps
-u interface PostListProps definisemo kakva treba biti funkcija fetchData
-funkciji PostList() dodajemo async
-funkciji PostList() dodajemo parametar destruktuirani prop fetchData
-parametru fetchData dodajemo tip PostListProps
-u funkciji PostList() dodajemo metodu await fetchData()
-vrijednost metode await fetchData() pohranjujemo u varijablu const posts
-dodajemo metodu posts.map()
-vrijednost metode posts.map() pohranjujemo u varijablu const renderedPosts
-u jsx-u, u div elemen dodajemo varijablu renderedPosts
-u [slug]/page.tsx fajl importujemo funkciju fetchPostsByTopicSlug i komponentu PostList.tsx
-u jsx-u, u div elementu dodajemo komponentu PostList
-komponenti PostList dodajemo prop fetchData
-u prop fetchData proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju fetchPostsByTopicSlug(slug)
-u pretrazivacu otvorimo link npr http://localhost:3000/topics/javascript

99. Alternative Type Names and Query Definitions
-alternativni nacin za kreiranje tipa PostWithData

100. Don't Go Crazy With Reuse
-u komponentu PostShow.tsx importujemo instancu db
-u interface PostShowProps dodajemo postId kao string
-funkciji PostShow() dodajemo parametar destruktuirani prop postId
-parametru postId dodajemo tip PostShowProps
-dodajemo metodu await db.post.findFirst()
-vrijednost metode await db.post.findFirst() pohranjujemo u varijablu const post
-dodajemo uslov if (!post)
-importujemo funkciju notFound iz paketa next/navigation
-u uslov if (!post) dodajemo funkciju notFound()
-u [postId]/page.tsx fajl importujemo komponentu PostShow.tsx
-u jsx-u dodajemo komponentu PostShow
-komponenti PostShow dodajemo prop postId
-u prop postId proslijedujemo varijablu postId
-importujemo i kreiramo komponentu Link

101. Comment Creation
-u [postId]/page.tsx fajl importujemo komponentu CommentCreateForm.tsx
-u jsx-u dodajemo komponentu CommentCreateForm sa prop postId i startOpen
-u prop postId proslijedujemo varijablu postId
-u create-comment.ts fajl dodajemo logiku za kreiranje komentara
-u ruti gdje se nalaze tema i objava kreiramo komentar

102. Recursively Rendering Components

103. Fetching the Big List
-u folderu queries kreiramo comments.ts fajl
-u comments.ts fajl importujemo instancu db i tip Comment
-kreiramo i eksportujemo tip CommentWithAuthor
-kreiramo i eksportujemo funkciju fetchCommentsByPostId()
-u funkciju fetchCommentsByPostId() dodajemo metodu db.comment.findMany()
-u komponentu CommentList.tsx importujemo tip CommentWithAuthor
-u interface CommentListProps definisemo vrijednost funkcije fetchData
-funkciji CommentList() dodajemo parametar destruktuirani prop fetchData
-u funkiju CommentList() dodajemo metodu await fetchData()
-vrijednost metode await fetchData() pohranjujemo u varijablu const comments
-u komponentu CommentShow.tsx importujemo tip CommentWithAuthor
-u interface CommentShowProps definisemo varijablu comments
-funkciji CommentShow() dodajemo parametar destruktuirani prop comments
-u [postId]/page.tsx fajl importujemo funkciju fetchCommentsByPostId
-importujemo komponentu CommentList.tsx
-u jsx dodajemo dodajemo komponentu CommentList
-komponenti CommentList dodajemo prop fetchData
-u prop fetchData proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju fetchCommentsByPostId(postId)
-kad otvorimo projekt u pretrazivacu kreiramo komentare 


Section 09: Caching with Request Memoization

104. Multiple Repeated DB Queries

105. Introducing Duplicate Queries
-u [postId]/page.tsx fajlu komponenti CommentList dodajemo prop postId
-u komponentu CommentList.tsx importujemo funkciju fetchCommentsByPostId
-funkciji CommentList() umjesto parametra fetchData dodajemo parametar postId
-umjesto metode await fetchData() dodajemo metodu await fetchCommentsByPostId(postId)
-u jsx-u, komponenti CommentList dodajemo prop postId umjesto fetchData
-u komponentu CommentShow.tsx importujemo funkciju fetchCommentsByPostId
-funkciji CommentShow() dodajemo async
-dodajemo metodu await fetchCommentsByPostId(postId)
-vrijednost metode await fetchCommentsByPostId(postId) pohranjujemo u varijablu const comments
-u jsx-u, komponenti CommentShow dodajemo prop postId umjesto comments

106. Request Memoization

107. Deduplicating Requests with Cache
-u comments.ts fajl importujemo funkciju cache iz paketa react
-dodajemo funkciju cache()
-vrijednost funkcije cache() pohranjujemo u varijablu const fetchCommentsByPostId


Section 10: Implementing Search Functionality

108. Adding in Component Streaming

109. Streaming with Suspense
-u PostShow.tsx fajl dodajemo metodu await new Promise()
-u [postId]/page.tsx fajl importujemo komponentu Suspense iz paketa react
-u jsx-u kreiramo komponentu Suspense sa otvorenim i zatvorenim tagom
-komponenti Suspense dodajemo prop fallback

110. Adding a Loading Skeleton
-u folderu posts kreiramo komponentu PostShowLoading.tsx
-u komponentu PostShowLoading.tsx importujemo komponentu Skeleton iz paketa nextui/react
-u [pageId]/page.tsx fajl importujemo komponentu PostShowLoading.tsx
-u prop fallback proslijedujemo komponentu PostShowLoading

111. Top Posts on the HomePage
-u posts.ts fajlu kreiramo i eksportujemo asinhronu funkciju fetchTopPosts()
-funkciji fetchTopPosts() dodajemo tip Promise<PostWithData[]>
-u funkciju fetchTopPosts() dodajemo metodu db.post.findMany()
-u funkciju findMany() dodajemo opcije orderBy, include i take
-u app/page.tsx fajl importujemo komponentu PostList.tsx
-importujemo funkciju fetchTopPosts
-u jsx-u dodajemo komponentu PostList
-komponenti PostList dodajemo prop fetchData
-u prop fetchData proslijedujemo funkciju fetchTopPosts

112. Back to the Search Input
-u folderu components kreiramo komponentu SearchInput.tsx
-u komponentu Header.tsx importujemo komponentu SearchInput.tsx

113. Notes on QueryStrings in Next

114. Accessing the Query String
-u komponentu SearchInput.tsx dodajemo direktivu 'use client'
-importujemo i kreiramo funkciju useSearchParams iz paketa next/navigation
-vrijednost funkcije useSearchParams() pohranjujemo u varijablu const searchParams
-komponenti Input dodajemo prop defaultValue
-u prop defaultValue dodajemo metodu searchParams.get()
-u pretrazivacu otvorimo rutu http://localhost:3000/?term=javascript

115. Redirecting From a Server Action
-u folderu actions kreiramo search.ts fajl
-u search.ts fajl dodajemo direktivu 'use server'
-kreiramo i eksportujemo asinhronu funkciju search()
-funkciji search() dodajemo parametar formData
-parametru formData dodajemo tip FormData
-u funkciji search kreiramo varijablu const term
-importujemo i kreiramo funkciju redirect iz paketa next/navigation
-dodajemo uslov if 
-u uslov if dodajemo funkciju redirect('/')
-poslije uslva if dodajemo jos jednu funkciju redirect() u kojoj se nalazi varijabla term
-u intex.ts fajlu eksportujemo funkciju search
-u komponenti SearchInput.tsx dodajemo import * as actions 
-u jsx-u kreiramo form element sa prop action
-u prop action proslijedujemo funkciju actions.search
-komponenti Input dodajemo prop name
-u pretrazivacu otvorimo rutu http://localhost:3000/?term=javascript

116. Receiving the Query String in a Server Component
-u folderu app kreiramo folder search
-u folderu search kreiramo page.tsx fajl
-u search/page.tsx fajlu kreiramo i eksportujemo asinhronu funkciju SearchPage()
-kreiramo interface SearchPageProps
-funkciji SearchPage() dodajemo parametar destruktuirani prop searchParams
-parametru dodajemo tip SearchPageProps
-destruktuiramo varijablu const { term } iz varijable searchParams
-dodajemo uslov if (!term)
-importujemo funkciju redirect
-u uslov if (!term) dodajemo funkciju redirect('/')
-ujsx-u, u div element dodajemo varijablu term
-u pretrazivacu otvorimo rutu http://localhost:3000/search?term=javascript

117. Running the Search
-u posts.ts fajlu kreiramo i eksportujemo funkciju fetchPostsBySearchTerm()
-funkciji fetchPostsBySearchTerm() dodajemo tip Promise<PostWithData[]>
-u funkciju fetchPostsBySearchTerm() dodajemo metodu db.post.findMany()
-u funkciju findMany() dodajemo objekt i opcije include i where
-funkciji fetchPostsBySearchTerm() dodajemo parametar term i tip string
-u search/page.tsx fajl importujemo funkciju fetchPostsBySearchTerm i komponentu PostList.tsx
-u jsx dodajemo komponentu PostList
-komponente PostList dodajemo prop fetchData
-u prop fetchData proslijedujemo anonimnu funkciju 
-u anonimnu funkciju proslijedujemo funkciju fetchPostsBySearchTerm(term)

118. The De-Opt to Client Side Rendering Warning
-u komponentu Header.tsx importujemo komponentu Suspense iz paketa react
-u jsx-u kreiramo komponentu Suspense sa otvorenim i zatvorenim tagom
-u komponentu Suspense dodajemo komponentu SearchInput

119. Wrap Up!

120. Deploying Discuss App to Vercel with Postgres


Section 11: Supplement - React Primer 

121. A Note About the Following Lectures

122. Let's Build an App!
-otvorimo link: https://codesandbox.io/p/sandbox/react-pibc94

123. Critical Questions

124. A Few More Critical Questions

125. Node Setup
-otvorimo web stranicu https://nodejs.org/en
-u terminalu ukucamo komandu node -v
-instaliramo Node na racunaru

126. Creating a React Project
-u terminalu ukucamo komandu npx create-react-app jsx
-instaliramo React.js aplikaciju
-u terminalu ukucamo komandu npm start da pokrenemo aplikaciju

127. What is Create React App

128. Showing Basic Content
-obrisani nepotrebni fajlovi iz projekta jsx
-u index.js fajl dodajemo logiku za pokretanje React.js aplikacije

129. What is JSX ?
-otvorimo web stranicu https://babeljs.io/repl

130. Printing JavaScript Variables in JSX
-u funkciji App() kreiramo varijablu let message
-dodajemo uslov if (Math.random() > 0.5)
-u uslovu if redeklarisemo varijablu message
-u jsx, u h1 element dodajemo varijablu {message}

131. Shorthand JSX Expressions
-u funkciji App() kreiramo varijable const date i const time
-u h1 element dodajemo metodu new Date()

132. Typical Component Layouts
-u funkciji App() kreiramo varijable const name i const age
-u h1 element dodajemo varijable name i age

133. Customizing Elements with Props
-u funkciji App() kreiramo element input
-input elementu dodajemo prop style, type, number i min 

134. Converting HTML to JSX
-u funkciji App() kreiramo element textarea
-elementu textarea dodajemo prop autoFocus

135. Applying Styling in JSX

136. Extracting Components
-u folderu src kreiramo App.js fajl
-u index.js fajl importujemo komponentu App.js fajl

137. Module Systems Overview

138. Cheatsheet for JSX
-otvorimo link: https://jsx-notes.vercel.app/

139. Project Overview

140. Creating Core Components
-kreiramo React.js aplikaciju pdas
-kreiramo komponentu ProfileCard.js
-u komponentu App.js importujemo komponentu ProfileCard
-u komponenti App.js, u funkciju App() dodajemo tri komponente ProfileCard